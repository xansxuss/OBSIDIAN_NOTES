Linux 行程虛擬位址空間佈局
### 目錄
1. 簡介
2. 佈局
3. 參考文獻

1. 簡介
虛擬位址空間（Virtual Address Space）是作業系統為每個行程（process）所建立的位址抽象，讓每個行程看起來像擁有獨立且連續的主記憶體空間。這個抽象使得記憶體保護、分頁與地址轉換成為可能。
單一行程所能使用的虛擬位址範圍主要由硬體平台決定，具體來說是由 CPU 的位元寬度決定。例如：
32 位元 CPU：位址範圍為 
0到2^{32}-1，也就是 0x00000000 到 0xFFFFFFFF，合計大約 4 GB 的虛擬位址空間。

64 位元 CPU：理論上位址範圍為 
0到2^{64}−1（0x0000000000000000 到 0xFFFFFFFFFFFFFFFF），數量級非常大（約 18,446,744,073,709,551,615 個位址）。實務上作業系統不會也無需把全部位址都開放出來。
但注意：就算硬體給你 4 GB（32-bit）的位址空間，使用者行程通常也不會拿到整個空間──作業系統核心（kernel）與系統保留區會佔用一部分，因此使用者程式實際可用的位址範圍是經過分割與保護的。若行程存取未被允許的位址，就會發生例外（如 Linux 的 Segmentation fault、Windows 的「應用程式發生例外並關閉」等情況）。

2. 佈局
C/C++ 編譯連結後的可執行檔由多個 section（節）構成，例如 .text、.data、.bss、.rodata 等。當作業系統載入程式時，會依權限與屬性把多個 section 合併成映射段（segment）再對應到虛擬位址空間，以減少頁碎片與節省記憶體。

1. 段（segment）與節（section）要分清楚：section 是連結時（linking）的概念，segment 則是載入時（loading）的概念；系統是以 segment 作為單位來做記憶體映射。
    一般在 Linux 下，使用者行程的虛擬位址空間常可分為以下區段（依典型排列）：
    - 程式碼段（Text Segment）
        儲存可執行的機器碼（例如函式實作、不可變字串常數等）。通常是唯讀且可執行（r-x），以防止被任意改寫。
    - 初始化資料段（Data Segment）
        儲存已初始化的全域變數與 static 變數（例如 int g = 3;）。大小在編譯／連結時決定，屬於靜態分配。
    - 未初始化資料段（BSS Segment）
        儲存未初始化或預設為 0 的全域變數與 static 變數。連結時會知道大小，但記憶體內容由核心在載入時清 0。
    - 堆（Heap）
        用來放動態分配記憶體（malloc / new）。堆的位址方向通常往上成長（向高位址增加）。在某些情況下，若分配非常大的區塊，glibc 會改用 mmap 建立匿名映射而不是在堆上擴展。
    - 映射段（Memory Mapping segment）
        包含動態連結庫（shared libraries）、記憶體映射檔（mmap 映射的檔案）、以及匿名映射（例如大區塊的 heap 分配或共用記憶體）。映射段是動態的，可由程式與系統隨時建立與解除。
    - 堆疊（Stack）
        儲存函式的區域變數、參數、返回位址與呼叫者環境等。堆疊位址通常向下成長（向低位址增加使用量），整體大小可被系統或使用者限制（例如 Linux 可用 ulimit -s 或透過 setrlimit 調整）。64-bit Linux 預設的使用者堆疊大小通常在 MB 等級（常見約 8–10 MB，但會依系統差異）。
    - 核心空間（Kernel Space）
        位於行程看不到或被保護的區域，用來放作業系統核心與驅動程式。使用者程式不能直接存取；當行程發生系統呼叫或中斷進入核心態時，會切換到核心的執行上下文與核心堆疊。

權限分類（常見）
段的權限通常可概括為：
1. 可讀 + 可執行（例如 .text）
2. 可讀 + 可寫（例如 .data, .bss）
3. 只讀（例如 .rodata）

作業系統會把具有相同屬性的多個 section 合併成單一 segment 來映射，減少頁對齊造成的浪費。

mmap 與 malloc 的互動

在 Linux 中，mmap() 可以把檔案或匿名記憶體直接映射到虛擬位址空間，這對載入共享庫或做高速 I/O 很有用。glibc 的 malloc() 在分配大塊記憶體（超過 M_MMAP_THRESHOLD，預設約 128 KB）時，會選擇用 mmap 建立匿名映射而不是在傳統 heap 上擴展；這可以降低 fragment 並改進大型分配的管理，但也會改變記憶體回收行為（munmap 可即時回收映射的記憶體）。

| 段名           |                     儲存內容 | 分配方式  | 生長方向 | 讀寫特性      | 執行態  |
| ------------ | -----------------------: | ----- | ---: | --------- | ---- |
| 程式碼段（Text）   |           程式指令、字串常數、虛函式表 | 靜態分配  | 向高位址 | 只讀（+可執行）  | 使用者態 |
| 數據段（Data）    |       已初始化的全域與 static 變數 | 靜態分配  | 向高位址 | 可讀可寫      | 使用者態 |
| BSS 段        | 未初始化的全域與 static 變數（預設 0） | 靜態分配  | 向高位址 | 可讀可寫      | 使用者態 |
| 堆（Heap）      |         動態分配（malloc/new） | 動態分配  | 向高位址 | 可讀可寫      | 使用者態 |
| 映射段（mmap）    |          共享函式庫、檔案映射、匿名映射 | 動態分配  | 向高位址 | 依映射屬性     | 使用者態 |
| 堆疊（Stack）    |             局部變數、參數、返回位址 | 系統管理  | 向低位址 | 可讀可寫      | 使用者態 |
| 核心空間（Kernel） |                 核心程式碼與驅動 | 靜動態混合 |   雙向 | 使用者不可直接存取 | 核心態  |

程式碼範例（C++）：變數所在位置示意

``` cpp
#include <cstring>
int a = 0;           // a 在 data 段（初始化為 0）
char *p1;            // p1 在 BSS（未初始化），系統會預設為 nullptr（或 0）

int main() {
    int b = 0;               // b 在 stack（區域變數）
    char *p2 = (char*)"123456"; // 字串常數 "123456" 在 code/.rodata 段，p2 在 stack
    static int c = 0;        // c 在 data 段（static）
    const int d = 0;         // d 多半在 stack（編譯器可做優化）
    static const int e = 0;  // e 在 data/.rodata 段

    p1 = (char*)malloc(10);  // 分配的 10 bytes 在 heap（或 mmap，視實作與大小而定）
    strcpy(p1, "123456");    // "123456" 字串位於 .rodata（可能與上面的共用）
    // ...
    free(p1);
    return 0;
}
```

備註：實際編譯器與連結器可能會做常數合併與最佳化（例如相同字串常數可能合併到同一個記憶體位置）。
小結（系統性且務實的提醒）
虛擬位址空間大小受硬體（CPU 位元數）與作業系統設計限制；實際可用範圍還會被核心保留與映射策略影響。
程式的不同資料（code、data、bss、heap、stack、mmap）在位址空間有典型分區，但具體排列與大小會依系統、編譯選項、連結器與執行時行為而異。
當你在 debug segmentation fault 時，理解虛擬位址佈局能有效協助定位問題來源（堆/堆疊溢位、非法 mmap 存取、NULL 解參考等）。

參考文獻（原始來源整理）
https://blog.csdn.net/zhangskd/article/details/6956638
 — Linux 核心空間與使用者空間詳解
https://blog.csdn.net/love_gaohz/article/details/41310597
 — 程式或記憶體區域分配（五個段）
https://blog.csdn.net/quanzhongzhao/article/details/45575611
 — 進程記憶體分佈剖析
《深入理解電腦系統（中文版）》C1.7.3 虛擬記憶體；C9.7.2 Linux 虛擬記憶體系統
俞甲子、石凡等，《程式設計師的自我修養—連結、裝載與庫》，工業出版社，2009（進程虛存空間分佈）
https://www.cnblogs.com/huxiao-tee/p/4660352.html
 — 認真分析 mmap：是什麼、為什麼、怎麼用