### C++ 中的inline 用法

1. 引入inline 關鍵字的原因
在c/c++ 中，為了解決一些頻繁調用的小函數大量消耗棧空間（棧內存）的問題，特別的引入了inline修飾符，表示為內聯函數。

棧空間就是指放置程式的局部資料（也就是函數內資料）的記憶體空間。

在系統下，堆疊空間是有限的，假如頻繁大量的使用就會造成因堆疊空間不足而導致程式出錯的問題，如，函數的死循環遞歸呼叫的最終結果就是導致棧記憶體空間枯竭。

下面我們來看一個例子：

實例
``` cpp

#include <stdio.h>

inline const char* num_check(int v) { 
    return (v % 2) ? "奇" : "偶";
}

int main(void) {
    int i;
    for (i = 0; i < 100; i++)
        printf("%02d) %s\n", i, num_check(i));
    return 0;
}
​   
```
     
上面的例子就是標準的內聯函數的用法，使用inline修飾帶來的好處我們表面看不出來，其實，在內部的工作就是在每個for循環的內部任何調用dbtest(i)的地方都換成了(i%2>0)?"奇":"偶"，這樣就避免了頻繁調用函數對內存重複開闢所帶來的消耗。

2. inline使用限制
inline的使用是有所限制的，inline 只適合涵數體內代碼簡單的涵數使用，不能包含複雜的結構控制語句例如while、switch，並且不能內聯函數本身不能是直接遞歸函數（即，自己內部還調用自己的函數）。

3. inline僅是一個對編譯器的建議
inline函數只是一個對編譯器的建議，所以最後能否真正內聯，看編譯器的意思，它如果認為函數不復雜，能在呼叫點展開，就會真正內聯，並不是說聲明了內聯就會內聯，聲明內聯只是一個建議而已。

4. 建議inline 函數的定義放在標頭檔中
其次，因為內聯函數要在呼叫點展開，所以編譯器必須隨處可見內聯函數的定義，要不然就成了非內聯函數的呼叫了。所以，這要求每個呼叫了內聯函數的檔案都出現了該內聯函數的定義。

因此，將內聯函數的定義放在頭文件裡實現是合適的，省卻你為每個文件實現一次的麻煩。

聲明跟定義要一致：如果在每個文件裡都實現一次該內聯函數的話，那麼，最好保證每個定義都是一樣的，否則，將會引起未定義的行為。如果不是每個檔案裡的定義都一樣，那麼，編譯器展開的是哪一個，那要看具體的編譯器而定。所以，最好將內聯函數定義放在標頭檔中。

5. 類別中的成員函數與inline
定義在類別中的成員函數預設都是內聯的，如果在類別定義時就在類別內給出函數定義，那當然最好。如果在類別中未給成員函數定義，而又想內聯函數的話，那在類別外要加上inline，否則就認為不是內聯的。

``` cpp
class A { public : void Foo ( int x , int y ) { } }// 自動成為內聯函數
```

將成員函數的定義體放在類別宣告之中雖然能帶來書寫上的方便，但不是一種好的程式風格，上例應該改成：

``` cpp
// 頭檔
class A { public :
     void Foo ( int x , int y ) ;
 } // 定義文件 

inline void A :: Foo ( int x , int y ) { }    
```

6. inline 是一種"用於實現的關鍵字"
關鍵字inline必須與函數定義體放在一起才能使函數成為內聯，僅將inline放在函數聲明前面不起任何作用。

如下風格的函數Foo不能成為內聯函數：

``` cpp 
inline void Foo ( int x , int y ); // inline 只與函數宣告放在一起void Foo ( int x , int y ){}    
```

而如下風格的函數Foo則成為內聯函數：

``` cpp
void Foo ( int x , int y ); inline void Foo ( int x , int y ) {} // inline 與函數定義體放在一起  
```

所以說，inline 是一種"用於實現的關鍵字"，而不是一種"用於聲明的關鍵字"。一般地，使用者可以閱讀函數的聲明，但是看不到函數的定義。儘管在大多數教科書中內聯函數的聲明、定義體前面都加了inline 關鍵字，但我認為inline不應該出現在函數的聲明中。這個細節雖然不會影響函數的功能，但是體現了高品質C++/C 程式設計風格的一個基本原則：聲明與定義不可混為一談，使用者沒有必要、也不應該知道函數是否需要內聯。

7. 慎用inline
內聯能提高函數的執行效率，為什麼不把所有的函數定義成內聯函數？如果所有的函數都是內聯函數，還用得著"內聯"這個關鍵字嗎？ 
內聯是以程式碼膨脹（複製）為代價，僅僅省去了函數呼叫的開銷，從而提高函數的執行效率。 
如果執行函數體內程式碼的時間，比起函數呼叫的開銷較大，那麼效率的收穫會很少。另一方面，每一個內聯函數的呼叫都要複製程式碼，將使程式的總程式碼量增大，消耗更多的記憶體空間。

以下情況不宜使用內聯： 
   1. 如果函數體內的程式碼比較長，使用內聯將導致記憶體消耗代價較高。 
   2. 如果函數體內出現循環，那麼執行函數體內程式碼的時間會比函數呼叫的開銷大。類別的建構子和析構函式容易讓人誤解成使用內聯更有效。要當心建構函式和析構函式可能會隱藏一些行為，如"偷偷地"執行了基底類別或成員物件的建構函式和析構函式。所以不要隨便地將建構函式和析構函式的定義體放在類別宣告中。一個好的編譯器將會根據函數的定義體，自動地取消不值得的內聯（這進一步說明了inline 不應該出現在函數的宣告中）。

8. 總結
內聯函數並不是一個增強性能的靈丹妙藥。只有當函數非常短小的時候它才能得到我們想要的效果；但是，如果函數並不是很短而且在很多地方都被調用的話，那麼將會使得可執行體的體積增大。 
最令人煩惱的還是當編譯器拒絕內聯的時候。在老的實現中，結果很不盡人意，雖然在新的實現中有很大的改善，但是仍然還是不那麼完善的。一些編譯器能夠足夠的聰明來指出哪些函數可以內聯哪些不能，但是大多數編譯器就不那麼聰明了，因此這就需要我們的經驗來判斷。如果內聯函數不能增強效能，就避免使用它！