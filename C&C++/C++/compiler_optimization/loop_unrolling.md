### 什麼是循環展開？
循環展開，英文稱為Loop unwinding或loop unrolling，是一種犧牲程式的尺寸來加快程式的執行速度的最佳化方法。可以由程式設計師完成，也可由編譯器自動最佳化完成。循環展開最常用來降低迴圈開銷，為具有多個功能單元的處理器提供指令級並行。也有利於指令管線的調度。

### 循環展開對程式效能的影響
我們直接以實際程式碼向大家展示循環展開的作用，首先看未經循環展開優化的程式碼：

``` cpp
#include <iostream>
#include <chrono>

int main(){
    auto start = std::chrono::system_clock::now();
    int sum = 0;
    int count = 10000;
    //循环10000次累加
    for(int i = 0;i < count;i++){  
        sum += i;
    }
    auto end = std::chrono::system_clock::now();
    std::chrono::duration<double> dura = end - start;
    std::cout <<"共耗时："<< dura.count() << "s" << std::endl;
    return 0;
}
```

類似上面的這段程式碼是我們平常工作中常見到的，函數目的就是求得1+2+…+9998+9999的累加和，每次迴圈把i累加到sum變數上，循環次數共10000次。程式碼運行結果如下：

可以看出程式碼運行耗時0.0000279秒。

下面我們將循環展開一次，也就是把上述程式碼中的循環改為如下程式碼：

``` cpp
for(int i = 0;i < count;i += 2){
    sum += i;
    sum += i+1;
}
```

即每次循環將i和i+1一起累加到sum變數上，這樣可以把循環次數從10000次降低到5000次，由於CPU的高度流水線化，連續兩個加法指令增加耗時很低，所以此版本代碼可以一定程度上提高程序運行速度，運行結果如下：

程式碼運作耗時0.0000159秒，相較於未優化程式碼速度快了將近一倍。
當然，我們可以繼續增加循環展開次數以進一步提高程式運行速度，但是這個增加循環展開次數也是有限度的，當達到了CPU的最高吞吐量之後，繼續增加循環展開次數是沒有意義的。
上述循環展開後的程式碼仍然有進一步優化的空間，那就是消除連續指令的相關性，以達到指令級並行，我們可以看到循環展開後的程式碼，循環體中有兩條語句：sum += i 和sum += i+1，第二個語句sum += i+1依賴第一個字句：sum += i 和sum += i+1，第二個語句sum += i+1也能進一步提高性能來如果我們將循環體改為如下程式碼：

``` cpp
int sum1=0,sum2=0;
for(int i=0;i < count;i+=2){
    sum1 += i;
    sum2 += i+1;
}
sum = sum1 + sum2;
```

我們新建了兩個變數sum1和sum2用於儲存循環展開時兩個累加語句的累加結果，最後在循環體外將兩部分結果相加得到最終結果。此程式碼中兩個累加語句之間是互不相關的，所以CPU可以並行執行這兩個指令，以達到效能的進一步提升。下面是運行結果：

程式碼運行耗時0.0000073秒，相較於只進行循環展開的程式碼速度又快了將近一倍。

### 總結
由上面三段程式碼的運行速度比較可以看出，循環展開對程式效能有著重要的影響，可以減少分支預測錯誤次數，增加取消資料相關進一步利用並行執行提高速度的機會。但是，並不建議大家進行手動的循環展開，在程式碼中進行循環展開會導致程式的可讀性下降，程式碼膨脹。為了直觀感受循環展開對效能的影響，上述程式碼運行結果均是在不開編譯器優化的情況下進行的測試，其實在我們開啟了編譯器優化的時候，編譯器會自動對我們的循環代碼進行循環展開，讓我們可以在保持了代碼可讀性的同時，又能享受到循環展開對我們程序性能的提高。